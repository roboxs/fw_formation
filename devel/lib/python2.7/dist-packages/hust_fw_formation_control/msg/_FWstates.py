# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from hust_fw_formation_control/FWstates.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import geometry_msgs.msg

class FWstates(genpy.Message):
  _md5sum = "3a9dfc7015c39929bc474960d75372d7"
  _type = "hust_fw_formation_control/FWstates"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """# Message 固定翼的编队控制，可能用到的消息类型全定义
uint16 planeID

uint16 target_planeID

bool altitude_lock

bool in_air

string control_mode

float64 pitch_angle

float64 yaw_angle

bool yaw_valid

float64 roll_angle

float64 roll_traget_angle

float64 pitch_traget_angle

float64 yaw_traget_angle


geometry_msgs/Quaternion att_quater #姿态四元数，只能在外面弄下旋转矩阵了

float64 ground_speed_ned_n

float64 ground_speed_ned_e

float64 ground_speed_ned_d

float64 ground_speed

float64 ground_speed_traget

float64 global_vel_x

float64 global_vel_y

float64 global_vel_z


float64 air_speed

float64 wind_estimate_x

float64 wind_estimate_y

float64 wind_estimate_z

float64 relative_hight

float64 relative_hight_traget

float64 latitude

float64 altitude

float64 longitude

float64 relative_alt

float64 ned_altitude

float64 ned_pos_x

float64 ned_pos_y

float64 ned_pos_z

float64 ned_vel_x

float64 ned_vel_y

float64 ned_vel_z

float64 ned_acc_x

float64 ned_acc_y

float64 ned_acc_z

geometry_msgs/Vector3 ned_acc

float64 body_acc_x

float64 body_acc_y

float64 body_acc_z

geometry_msgs/Vector3 body_acc

float64 battery_voltage

float64 battery_precentage

float64 battery_current
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w

================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z"""
  __slots__ = ['planeID','target_planeID','altitude_lock','in_air','control_mode','pitch_angle','yaw_angle','yaw_valid','roll_angle','roll_traget_angle','pitch_traget_angle','yaw_traget_angle','att_quater','ground_speed_ned_n','ground_speed_ned_e','ground_speed_ned_d','ground_speed','ground_speed_traget','global_vel_x','global_vel_y','global_vel_z','air_speed','wind_estimate_x','wind_estimate_y','wind_estimate_z','relative_hight','relative_hight_traget','latitude','altitude','longitude','relative_alt','ned_altitude','ned_pos_x','ned_pos_y','ned_pos_z','ned_vel_x','ned_vel_y','ned_vel_z','ned_acc_x','ned_acc_y','ned_acc_z','ned_acc','body_acc_x','body_acc_y','body_acc_z','body_acc','battery_voltage','battery_precentage','battery_current']
  _slot_types = ['uint16','uint16','bool','bool','string','float64','float64','bool','float64','float64','float64','float64','geometry_msgs/Quaternion','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','geometry_msgs/Vector3','float64','float64','float64','geometry_msgs/Vector3','float64','float64','float64']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       planeID,target_planeID,altitude_lock,in_air,control_mode,pitch_angle,yaw_angle,yaw_valid,roll_angle,roll_traget_angle,pitch_traget_angle,yaw_traget_angle,att_quater,ground_speed_ned_n,ground_speed_ned_e,ground_speed_ned_d,ground_speed,ground_speed_traget,global_vel_x,global_vel_y,global_vel_z,air_speed,wind_estimate_x,wind_estimate_y,wind_estimate_z,relative_hight,relative_hight_traget,latitude,altitude,longitude,relative_alt,ned_altitude,ned_pos_x,ned_pos_y,ned_pos_z,ned_vel_x,ned_vel_y,ned_vel_z,ned_acc_x,ned_acc_y,ned_acc_z,ned_acc,body_acc_x,body_acc_y,body_acc_z,body_acc,battery_voltage,battery_precentage,battery_current

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(FWstates, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.planeID is None:
        self.planeID = 0
      if self.target_planeID is None:
        self.target_planeID = 0
      if self.altitude_lock is None:
        self.altitude_lock = False
      if self.in_air is None:
        self.in_air = False
      if self.control_mode is None:
        self.control_mode = ''
      if self.pitch_angle is None:
        self.pitch_angle = 0.
      if self.yaw_angle is None:
        self.yaw_angle = 0.
      if self.yaw_valid is None:
        self.yaw_valid = False
      if self.roll_angle is None:
        self.roll_angle = 0.
      if self.roll_traget_angle is None:
        self.roll_traget_angle = 0.
      if self.pitch_traget_angle is None:
        self.pitch_traget_angle = 0.
      if self.yaw_traget_angle is None:
        self.yaw_traget_angle = 0.
      if self.att_quater is None:
        self.att_quater = geometry_msgs.msg.Quaternion()
      if self.ground_speed_ned_n is None:
        self.ground_speed_ned_n = 0.
      if self.ground_speed_ned_e is None:
        self.ground_speed_ned_e = 0.
      if self.ground_speed_ned_d is None:
        self.ground_speed_ned_d = 0.
      if self.ground_speed is None:
        self.ground_speed = 0.
      if self.ground_speed_traget is None:
        self.ground_speed_traget = 0.
      if self.global_vel_x is None:
        self.global_vel_x = 0.
      if self.global_vel_y is None:
        self.global_vel_y = 0.
      if self.global_vel_z is None:
        self.global_vel_z = 0.
      if self.air_speed is None:
        self.air_speed = 0.
      if self.wind_estimate_x is None:
        self.wind_estimate_x = 0.
      if self.wind_estimate_y is None:
        self.wind_estimate_y = 0.
      if self.wind_estimate_z is None:
        self.wind_estimate_z = 0.
      if self.relative_hight is None:
        self.relative_hight = 0.
      if self.relative_hight_traget is None:
        self.relative_hight_traget = 0.
      if self.latitude is None:
        self.latitude = 0.
      if self.altitude is None:
        self.altitude = 0.
      if self.longitude is None:
        self.longitude = 0.
      if self.relative_alt is None:
        self.relative_alt = 0.
      if self.ned_altitude is None:
        self.ned_altitude = 0.
      if self.ned_pos_x is None:
        self.ned_pos_x = 0.
      if self.ned_pos_y is None:
        self.ned_pos_y = 0.
      if self.ned_pos_z is None:
        self.ned_pos_z = 0.
      if self.ned_vel_x is None:
        self.ned_vel_x = 0.
      if self.ned_vel_y is None:
        self.ned_vel_y = 0.
      if self.ned_vel_z is None:
        self.ned_vel_z = 0.
      if self.ned_acc_x is None:
        self.ned_acc_x = 0.
      if self.ned_acc_y is None:
        self.ned_acc_y = 0.
      if self.ned_acc_z is None:
        self.ned_acc_z = 0.
      if self.ned_acc is None:
        self.ned_acc = geometry_msgs.msg.Vector3()
      if self.body_acc_x is None:
        self.body_acc_x = 0.
      if self.body_acc_y is None:
        self.body_acc_y = 0.
      if self.body_acc_z is None:
        self.body_acc_z = 0.
      if self.body_acc is None:
        self.body_acc = geometry_msgs.msg.Vector3()
      if self.battery_voltage is None:
        self.battery_voltage = 0.
      if self.battery_precentage is None:
        self.battery_precentage = 0.
      if self.battery_current is None:
        self.battery_current = 0.
    else:
      self.planeID = 0
      self.target_planeID = 0
      self.altitude_lock = False
      self.in_air = False
      self.control_mode = ''
      self.pitch_angle = 0.
      self.yaw_angle = 0.
      self.yaw_valid = False
      self.roll_angle = 0.
      self.roll_traget_angle = 0.
      self.pitch_traget_angle = 0.
      self.yaw_traget_angle = 0.
      self.att_quater = geometry_msgs.msg.Quaternion()
      self.ground_speed_ned_n = 0.
      self.ground_speed_ned_e = 0.
      self.ground_speed_ned_d = 0.
      self.ground_speed = 0.
      self.ground_speed_traget = 0.
      self.global_vel_x = 0.
      self.global_vel_y = 0.
      self.global_vel_z = 0.
      self.air_speed = 0.
      self.wind_estimate_x = 0.
      self.wind_estimate_y = 0.
      self.wind_estimate_z = 0.
      self.relative_hight = 0.
      self.relative_hight_traget = 0.
      self.latitude = 0.
      self.altitude = 0.
      self.longitude = 0.
      self.relative_alt = 0.
      self.ned_altitude = 0.
      self.ned_pos_x = 0.
      self.ned_pos_y = 0.
      self.ned_pos_z = 0.
      self.ned_vel_x = 0.
      self.ned_vel_y = 0.
      self.ned_vel_z = 0.
      self.ned_acc_x = 0.
      self.ned_acc_y = 0.
      self.ned_acc_z = 0.
      self.ned_acc = geometry_msgs.msg.Vector3()
      self.body_acc_x = 0.
      self.body_acc_y = 0.
      self.body_acc_z = 0.
      self.body_acc = geometry_msgs.msg.Vector3()
      self.battery_voltage = 0.
      self.battery_precentage = 0.
      self.battery_current = 0.

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_2H2B().pack(_x.planeID, _x.target_planeID, _x.altitude_lock, _x.in_air))
      _x = self.control_mode
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2dB48d().pack(_x.pitch_angle, _x.yaw_angle, _x.yaw_valid, _x.roll_angle, _x.roll_traget_angle, _x.pitch_traget_angle, _x.yaw_traget_angle, _x.att_quater.x, _x.att_quater.y, _x.att_quater.z, _x.att_quater.w, _x.ground_speed_ned_n, _x.ground_speed_ned_e, _x.ground_speed_ned_d, _x.ground_speed, _x.ground_speed_traget, _x.global_vel_x, _x.global_vel_y, _x.global_vel_z, _x.air_speed, _x.wind_estimate_x, _x.wind_estimate_y, _x.wind_estimate_z, _x.relative_hight, _x.relative_hight_traget, _x.latitude, _x.altitude, _x.longitude, _x.relative_alt, _x.ned_altitude, _x.ned_pos_x, _x.ned_pos_y, _x.ned_pos_z, _x.ned_vel_x, _x.ned_vel_y, _x.ned_vel_z, _x.ned_acc_x, _x.ned_acc_y, _x.ned_acc_z, _x.ned_acc.x, _x.ned_acc.y, _x.ned_acc.z, _x.body_acc_x, _x.body_acc_y, _x.body_acc_z, _x.body_acc.x, _x.body_acc.y, _x.body_acc.z, _x.battery_voltage, _x.battery_precentage, _x.battery_current))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.att_quater is None:
        self.att_quater = geometry_msgs.msg.Quaternion()
      if self.ned_acc is None:
        self.ned_acc = geometry_msgs.msg.Vector3()
      if self.body_acc is None:
        self.body_acc = geometry_msgs.msg.Vector3()
      end = 0
      _x = self
      start = end
      end += 6
      (_x.planeID, _x.target_planeID, _x.altitude_lock, _x.in_air,) = _get_struct_2H2B().unpack(str[start:end])
      self.altitude_lock = bool(self.altitude_lock)
      self.in_air = bool(self.in_air)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.control_mode = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.control_mode = str[start:end]
      _x = self
      start = end
      end += 401
      (_x.pitch_angle, _x.yaw_angle, _x.yaw_valid, _x.roll_angle, _x.roll_traget_angle, _x.pitch_traget_angle, _x.yaw_traget_angle, _x.att_quater.x, _x.att_quater.y, _x.att_quater.z, _x.att_quater.w, _x.ground_speed_ned_n, _x.ground_speed_ned_e, _x.ground_speed_ned_d, _x.ground_speed, _x.ground_speed_traget, _x.global_vel_x, _x.global_vel_y, _x.global_vel_z, _x.air_speed, _x.wind_estimate_x, _x.wind_estimate_y, _x.wind_estimate_z, _x.relative_hight, _x.relative_hight_traget, _x.latitude, _x.altitude, _x.longitude, _x.relative_alt, _x.ned_altitude, _x.ned_pos_x, _x.ned_pos_y, _x.ned_pos_z, _x.ned_vel_x, _x.ned_vel_y, _x.ned_vel_z, _x.ned_acc_x, _x.ned_acc_y, _x.ned_acc_z, _x.ned_acc.x, _x.ned_acc.y, _x.ned_acc.z, _x.body_acc_x, _x.body_acc_y, _x.body_acc_z, _x.body_acc.x, _x.body_acc.y, _x.body_acc.z, _x.battery_voltage, _x.battery_precentage, _x.battery_current,) = _get_struct_2dB48d().unpack(str[start:end])
      self.yaw_valid = bool(self.yaw_valid)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_2H2B().pack(_x.planeID, _x.target_planeID, _x.altitude_lock, _x.in_air))
      _x = self.control_mode
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_2dB48d().pack(_x.pitch_angle, _x.yaw_angle, _x.yaw_valid, _x.roll_angle, _x.roll_traget_angle, _x.pitch_traget_angle, _x.yaw_traget_angle, _x.att_quater.x, _x.att_quater.y, _x.att_quater.z, _x.att_quater.w, _x.ground_speed_ned_n, _x.ground_speed_ned_e, _x.ground_speed_ned_d, _x.ground_speed, _x.ground_speed_traget, _x.global_vel_x, _x.global_vel_y, _x.global_vel_z, _x.air_speed, _x.wind_estimate_x, _x.wind_estimate_y, _x.wind_estimate_z, _x.relative_hight, _x.relative_hight_traget, _x.latitude, _x.altitude, _x.longitude, _x.relative_alt, _x.ned_altitude, _x.ned_pos_x, _x.ned_pos_y, _x.ned_pos_z, _x.ned_vel_x, _x.ned_vel_y, _x.ned_vel_z, _x.ned_acc_x, _x.ned_acc_y, _x.ned_acc_z, _x.ned_acc.x, _x.ned_acc.y, _x.ned_acc.z, _x.body_acc_x, _x.body_acc_y, _x.body_acc_z, _x.body_acc.x, _x.body_acc.y, _x.body_acc.z, _x.battery_voltage, _x.battery_precentage, _x.battery_current))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.att_quater is None:
        self.att_quater = geometry_msgs.msg.Quaternion()
      if self.ned_acc is None:
        self.ned_acc = geometry_msgs.msg.Vector3()
      if self.body_acc is None:
        self.body_acc = geometry_msgs.msg.Vector3()
      end = 0
      _x = self
      start = end
      end += 6
      (_x.planeID, _x.target_planeID, _x.altitude_lock, _x.in_air,) = _get_struct_2H2B().unpack(str[start:end])
      self.altitude_lock = bool(self.altitude_lock)
      self.in_air = bool(self.in_air)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.control_mode = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.control_mode = str[start:end]
      _x = self
      start = end
      end += 401
      (_x.pitch_angle, _x.yaw_angle, _x.yaw_valid, _x.roll_angle, _x.roll_traget_angle, _x.pitch_traget_angle, _x.yaw_traget_angle, _x.att_quater.x, _x.att_quater.y, _x.att_quater.z, _x.att_quater.w, _x.ground_speed_ned_n, _x.ground_speed_ned_e, _x.ground_speed_ned_d, _x.ground_speed, _x.ground_speed_traget, _x.global_vel_x, _x.global_vel_y, _x.global_vel_z, _x.air_speed, _x.wind_estimate_x, _x.wind_estimate_y, _x.wind_estimate_z, _x.relative_hight, _x.relative_hight_traget, _x.latitude, _x.altitude, _x.longitude, _x.relative_alt, _x.ned_altitude, _x.ned_pos_x, _x.ned_pos_y, _x.ned_pos_z, _x.ned_vel_x, _x.ned_vel_y, _x.ned_vel_z, _x.ned_acc_x, _x.ned_acc_y, _x.ned_acc_z, _x.ned_acc.x, _x.ned_acc.y, _x.ned_acc.z, _x.body_acc_x, _x.body_acc_y, _x.body_acc_z, _x.body_acc.x, _x.body_acc.y, _x.body_acc.z, _x.battery_voltage, _x.battery_precentage, _x.battery_current,) = _get_struct_2dB48d().unpack(str[start:end])
      self.yaw_valid = bool(self.yaw_valid)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2H2B = None
def _get_struct_2H2B():
    global _struct_2H2B
    if _struct_2H2B is None:
        _struct_2H2B = struct.Struct("<2H2B")
    return _struct_2H2B
_struct_2dB48d = None
def _get_struct_2dB48d():
    global _struct_2dB48d
    if _struct_2dB48d is None:
        _struct_2dB48d = struct.Struct("<2dB48d")
    return _struct_2dB48d
