# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from hust_fw_formation_control/Leaderstates.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class Leaderstates(genpy.Message):
  _md5sum = "68a80b14eea42d16a0353d5db35bf100"
  _type = "hust_fw_formation_control/Leaderstates"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """#本消息是定义的领机的状态消息，同样也包含了相对运动的关系

#如果能得到领机的当前姿态信息，相当于协同
float64 pitch_angle

float64 yaw_angle

bool yaw_valid

float64 roll_angle

float64 thrust#这个有点不好获得

#领机的绝对位置速度信息
float64 latitude

float64 altitude

float64 longitude

float64 relative_alt

float64 airspeed

float64 ned_vel_x

float64 ned_vel_y

float64 ned_vel_z

float64 global_vel_x

float64 global_vel_y

float64 global_vel_z

float64 ned_acc_x

float64 ned_acc_y

float64 ned_acc_z

float64 body_acc_x

float64 body_acc_y

float64 body_acc_z

#领机与本机相对位置速度信息
float64 rel_pos_Xb

float64 rel_pos_Yb

float64 rel_pos_Zb

float64 rel_vel_Xb

float64 rel_vel_Yb

float64 rel_vel_Zb

float64 rel_angle_a#相对角度，之后再改名

float64 rel_angle_b

float64 rel_angle_c

float64 rel_att_pitch

float64 rel_att_roll

float64 rel_att_yaw"""
  __slots__ = ['pitch_angle','yaw_angle','yaw_valid','roll_angle','thrust','latitude','altitude','longitude','relative_alt','airspeed','ned_vel_x','ned_vel_y','ned_vel_z','global_vel_x','global_vel_y','global_vel_z','ned_acc_x','ned_acc_y','ned_acc_z','body_acc_x','body_acc_y','body_acc_z','rel_pos_Xb','rel_pos_Yb','rel_pos_Zb','rel_vel_Xb','rel_vel_Yb','rel_vel_Zb','rel_angle_a','rel_angle_b','rel_angle_c','rel_att_pitch','rel_att_roll','rel_att_yaw']
  _slot_types = ['float64','float64','bool','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       pitch_angle,yaw_angle,yaw_valid,roll_angle,thrust,latitude,altitude,longitude,relative_alt,airspeed,ned_vel_x,ned_vel_y,ned_vel_z,global_vel_x,global_vel_y,global_vel_z,ned_acc_x,ned_acc_y,ned_acc_z,body_acc_x,body_acc_y,body_acc_z,rel_pos_Xb,rel_pos_Yb,rel_pos_Zb,rel_vel_Xb,rel_vel_Yb,rel_vel_Zb,rel_angle_a,rel_angle_b,rel_angle_c,rel_att_pitch,rel_att_roll,rel_att_yaw

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(Leaderstates, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.pitch_angle is None:
        self.pitch_angle = 0.
      if self.yaw_angle is None:
        self.yaw_angle = 0.
      if self.yaw_valid is None:
        self.yaw_valid = False
      if self.roll_angle is None:
        self.roll_angle = 0.
      if self.thrust is None:
        self.thrust = 0.
      if self.latitude is None:
        self.latitude = 0.
      if self.altitude is None:
        self.altitude = 0.
      if self.longitude is None:
        self.longitude = 0.
      if self.relative_alt is None:
        self.relative_alt = 0.
      if self.airspeed is None:
        self.airspeed = 0.
      if self.ned_vel_x is None:
        self.ned_vel_x = 0.
      if self.ned_vel_y is None:
        self.ned_vel_y = 0.
      if self.ned_vel_z is None:
        self.ned_vel_z = 0.
      if self.global_vel_x is None:
        self.global_vel_x = 0.
      if self.global_vel_y is None:
        self.global_vel_y = 0.
      if self.global_vel_z is None:
        self.global_vel_z = 0.
      if self.ned_acc_x is None:
        self.ned_acc_x = 0.
      if self.ned_acc_y is None:
        self.ned_acc_y = 0.
      if self.ned_acc_z is None:
        self.ned_acc_z = 0.
      if self.body_acc_x is None:
        self.body_acc_x = 0.
      if self.body_acc_y is None:
        self.body_acc_y = 0.
      if self.body_acc_z is None:
        self.body_acc_z = 0.
      if self.rel_pos_Xb is None:
        self.rel_pos_Xb = 0.
      if self.rel_pos_Yb is None:
        self.rel_pos_Yb = 0.
      if self.rel_pos_Zb is None:
        self.rel_pos_Zb = 0.
      if self.rel_vel_Xb is None:
        self.rel_vel_Xb = 0.
      if self.rel_vel_Yb is None:
        self.rel_vel_Yb = 0.
      if self.rel_vel_Zb is None:
        self.rel_vel_Zb = 0.
      if self.rel_angle_a is None:
        self.rel_angle_a = 0.
      if self.rel_angle_b is None:
        self.rel_angle_b = 0.
      if self.rel_angle_c is None:
        self.rel_angle_c = 0.
      if self.rel_att_pitch is None:
        self.rel_att_pitch = 0.
      if self.rel_att_roll is None:
        self.rel_att_roll = 0.
      if self.rel_att_yaw is None:
        self.rel_att_yaw = 0.
    else:
      self.pitch_angle = 0.
      self.yaw_angle = 0.
      self.yaw_valid = False
      self.roll_angle = 0.
      self.thrust = 0.
      self.latitude = 0.
      self.altitude = 0.
      self.longitude = 0.
      self.relative_alt = 0.
      self.airspeed = 0.
      self.ned_vel_x = 0.
      self.ned_vel_y = 0.
      self.ned_vel_z = 0.
      self.global_vel_x = 0.
      self.global_vel_y = 0.
      self.global_vel_z = 0.
      self.ned_acc_x = 0.
      self.ned_acc_y = 0.
      self.ned_acc_z = 0.
      self.body_acc_x = 0.
      self.body_acc_y = 0.
      self.body_acc_z = 0.
      self.rel_pos_Xb = 0.
      self.rel_pos_Yb = 0.
      self.rel_pos_Zb = 0.
      self.rel_vel_Xb = 0.
      self.rel_vel_Yb = 0.
      self.rel_vel_Zb = 0.
      self.rel_angle_a = 0.
      self.rel_angle_b = 0.
      self.rel_angle_c = 0.
      self.rel_att_pitch = 0.
      self.rel_att_roll = 0.
      self.rel_att_yaw = 0.

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_2dB31d().pack(_x.pitch_angle, _x.yaw_angle, _x.yaw_valid, _x.roll_angle, _x.thrust, _x.latitude, _x.altitude, _x.longitude, _x.relative_alt, _x.airspeed, _x.ned_vel_x, _x.ned_vel_y, _x.ned_vel_z, _x.global_vel_x, _x.global_vel_y, _x.global_vel_z, _x.ned_acc_x, _x.ned_acc_y, _x.ned_acc_z, _x.body_acc_x, _x.body_acc_y, _x.body_acc_z, _x.rel_pos_Xb, _x.rel_pos_Yb, _x.rel_pos_Zb, _x.rel_vel_Xb, _x.rel_vel_Yb, _x.rel_vel_Zb, _x.rel_angle_a, _x.rel_angle_b, _x.rel_angle_c, _x.rel_att_pitch, _x.rel_att_roll, _x.rel_att_yaw))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 265
      (_x.pitch_angle, _x.yaw_angle, _x.yaw_valid, _x.roll_angle, _x.thrust, _x.latitude, _x.altitude, _x.longitude, _x.relative_alt, _x.airspeed, _x.ned_vel_x, _x.ned_vel_y, _x.ned_vel_z, _x.global_vel_x, _x.global_vel_y, _x.global_vel_z, _x.ned_acc_x, _x.ned_acc_y, _x.ned_acc_z, _x.body_acc_x, _x.body_acc_y, _x.body_acc_z, _x.rel_pos_Xb, _x.rel_pos_Yb, _x.rel_pos_Zb, _x.rel_vel_Xb, _x.rel_vel_Yb, _x.rel_vel_Zb, _x.rel_angle_a, _x.rel_angle_b, _x.rel_angle_c, _x.rel_att_pitch, _x.rel_att_roll, _x.rel_att_yaw,) = _get_struct_2dB31d().unpack(str[start:end])
      self.yaw_valid = bool(self.yaw_valid)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_2dB31d().pack(_x.pitch_angle, _x.yaw_angle, _x.yaw_valid, _x.roll_angle, _x.thrust, _x.latitude, _x.altitude, _x.longitude, _x.relative_alt, _x.airspeed, _x.ned_vel_x, _x.ned_vel_y, _x.ned_vel_z, _x.global_vel_x, _x.global_vel_y, _x.global_vel_z, _x.ned_acc_x, _x.ned_acc_y, _x.ned_acc_z, _x.body_acc_x, _x.body_acc_y, _x.body_acc_z, _x.rel_pos_Xb, _x.rel_pos_Yb, _x.rel_pos_Zb, _x.rel_vel_Xb, _x.rel_vel_Yb, _x.rel_vel_Zb, _x.rel_angle_a, _x.rel_angle_b, _x.rel_angle_c, _x.rel_att_pitch, _x.rel_att_roll, _x.rel_att_yaw))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 265
      (_x.pitch_angle, _x.yaw_angle, _x.yaw_valid, _x.roll_angle, _x.thrust, _x.latitude, _x.altitude, _x.longitude, _x.relative_alt, _x.airspeed, _x.ned_vel_x, _x.ned_vel_y, _x.ned_vel_z, _x.global_vel_x, _x.global_vel_y, _x.global_vel_z, _x.ned_acc_x, _x.ned_acc_y, _x.ned_acc_z, _x.body_acc_x, _x.body_acc_y, _x.body_acc_z, _x.rel_pos_Xb, _x.rel_pos_Yb, _x.rel_pos_Zb, _x.rel_vel_Xb, _x.rel_vel_Yb, _x.rel_vel_Zb, _x.rel_angle_a, _x.rel_angle_b, _x.rel_angle_c, _x.rel_att_pitch, _x.rel_att_roll, _x.rel_att_yaw,) = _get_struct_2dB31d().unpack(str[start:end])
      self.yaw_valid = bool(self.yaw_valid)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_2dB31d = None
def _get_struct_2dB31d():
    global _struct_2dB31d
    if _struct_2dB31d is None:
        _struct_2dB31d = struct.Struct("<2dB31d")
    return _struct_2dB31d
