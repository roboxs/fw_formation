// Generated by gencpp from file hust_fw_formation_control/FWstates.msg
// DO NOT EDIT!


#ifndef HUST_FW_FORMATION_CONTROL_MESSAGE_FWSTATES_H
#define HUST_FW_FORMATION_CONTROL_MESSAGE_FWSTATES_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <geometry_msgs/Quaternion.h>
#include <geometry_msgs/Vector3.h>
#include <geometry_msgs/Vector3.h>

namespace hust_fw_formation_control
{
template <class ContainerAllocator>
struct FWstates_
{
  typedef FWstates_<ContainerAllocator> Type;

  FWstates_()
    : planeID(0)
    , target_planeID(0)
    , altitude_lock(false)
    , in_air(false)
    , control_mode()
    , pitch_angle(0.0)
    , yaw_angle(0.0)
    , yaw_valid(false)
    , roll_angle(0.0)
    , roll_traget_angle(0.0)
    , pitch_traget_angle(0.0)
    , yaw_traget_angle(0.0)
    , att_quater()
    , ground_speed_ned_n(0.0)
    , ground_speed_ned_e(0.0)
    , ground_speed_ned_d(0.0)
    , ground_speed(0.0)
    , ground_speed_traget(0.0)
    , global_vel_x(0.0)
    , global_vel_y(0.0)
    , global_vel_z(0.0)
    , air_speed(0.0)
    , wind_estimate_x(0.0)
    , wind_estimate_y(0.0)
    , wind_estimate_z(0.0)
    , relative_hight(0.0)
    , relative_hight_traget(0.0)
    , latitude(0.0)
    , altitude(0.0)
    , longitude(0.0)
    , relative_alt(0.0)
    , ned_altitude(0.0)
    , ned_pos_x(0.0)
    , ned_pos_y(0.0)
    , ned_pos_z(0.0)
    , ned_vel_x(0.0)
    , ned_vel_y(0.0)
    , ned_vel_z(0.0)
    , ned_acc_x(0.0)
    , ned_acc_y(0.0)
    , ned_acc_z(0.0)
    , ned_acc()
    , body_acc_x(0.0)
    , body_acc_y(0.0)
    , body_acc_z(0.0)
    , body_acc()
    , battery_voltage(0.0)
    , battery_precentage(0.0)
    , battery_current(0.0)  {
    }
  FWstates_(const ContainerAllocator& _alloc)
    : planeID(0)
    , target_planeID(0)
    , altitude_lock(false)
    , in_air(false)
    , control_mode(_alloc)
    , pitch_angle(0.0)
    , yaw_angle(0.0)
    , yaw_valid(false)
    , roll_angle(0.0)
    , roll_traget_angle(0.0)
    , pitch_traget_angle(0.0)
    , yaw_traget_angle(0.0)
    , att_quater(_alloc)
    , ground_speed_ned_n(0.0)
    , ground_speed_ned_e(0.0)
    , ground_speed_ned_d(0.0)
    , ground_speed(0.0)
    , ground_speed_traget(0.0)
    , global_vel_x(0.0)
    , global_vel_y(0.0)
    , global_vel_z(0.0)
    , air_speed(0.0)
    , wind_estimate_x(0.0)
    , wind_estimate_y(0.0)
    , wind_estimate_z(0.0)
    , relative_hight(0.0)
    , relative_hight_traget(0.0)
    , latitude(0.0)
    , altitude(0.0)
    , longitude(0.0)
    , relative_alt(0.0)
    , ned_altitude(0.0)
    , ned_pos_x(0.0)
    , ned_pos_y(0.0)
    , ned_pos_z(0.0)
    , ned_vel_x(0.0)
    , ned_vel_y(0.0)
    , ned_vel_z(0.0)
    , ned_acc_x(0.0)
    , ned_acc_y(0.0)
    , ned_acc_z(0.0)
    , ned_acc(_alloc)
    , body_acc_x(0.0)
    , body_acc_y(0.0)
    , body_acc_z(0.0)
    , body_acc(_alloc)
    , battery_voltage(0.0)
    , battery_precentage(0.0)
    , battery_current(0.0)  {
  (void)_alloc;
    }



   typedef uint16_t _planeID_type;
  _planeID_type planeID;

   typedef uint16_t _target_planeID_type;
  _target_planeID_type target_planeID;

   typedef uint8_t _altitude_lock_type;
  _altitude_lock_type altitude_lock;

   typedef uint8_t _in_air_type;
  _in_air_type in_air;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _control_mode_type;
  _control_mode_type control_mode;

   typedef double _pitch_angle_type;
  _pitch_angle_type pitch_angle;

   typedef double _yaw_angle_type;
  _yaw_angle_type yaw_angle;

   typedef uint8_t _yaw_valid_type;
  _yaw_valid_type yaw_valid;

   typedef double _roll_angle_type;
  _roll_angle_type roll_angle;

   typedef double _roll_traget_angle_type;
  _roll_traget_angle_type roll_traget_angle;

   typedef double _pitch_traget_angle_type;
  _pitch_traget_angle_type pitch_traget_angle;

   typedef double _yaw_traget_angle_type;
  _yaw_traget_angle_type yaw_traget_angle;

   typedef  ::geometry_msgs::Quaternion_<ContainerAllocator>  _att_quater_type;
  _att_quater_type att_quater;

   typedef double _ground_speed_ned_n_type;
  _ground_speed_ned_n_type ground_speed_ned_n;

   typedef double _ground_speed_ned_e_type;
  _ground_speed_ned_e_type ground_speed_ned_e;

   typedef double _ground_speed_ned_d_type;
  _ground_speed_ned_d_type ground_speed_ned_d;

   typedef double _ground_speed_type;
  _ground_speed_type ground_speed;

   typedef double _ground_speed_traget_type;
  _ground_speed_traget_type ground_speed_traget;

   typedef double _global_vel_x_type;
  _global_vel_x_type global_vel_x;

   typedef double _global_vel_y_type;
  _global_vel_y_type global_vel_y;

   typedef double _global_vel_z_type;
  _global_vel_z_type global_vel_z;

   typedef double _air_speed_type;
  _air_speed_type air_speed;

   typedef double _wind_estimate_x_type;
  _wind_estimate_x_type wind_estimate_x;

   typedef double _wind_estimate_y_type;
  _wind_estimate_y_type wind_estimate_y;

   typedef double _wind_estimate_z_type;
  _wind_estimate_z_type wind_estimate_z;

   typedef double _relative_hight_type;
  _relative_hight_type relative_hight;

   typedef double _relative_hight_traget_type;
  _relative_hight_traget_type relative_hight_traget;

   typedef double _latitude_type;
  _latitude_type latitude;

   typedef double _altitude_type;
  _altitude_type altitude;

   typedef double _longitude_type;
  _longitude_type longitude;

   typedef double _relative_alt_type;
  _relative_alt_type relative_alt;

   typedef double _ned_altitude_type;
  _ned_altitude_type ned_altitude;

   typedef double _ned_pos_x_type;
  _ned_pos_x_type ned_pos_x;

   typedef double _ned_pos_y_type;
  _ned_pos_y_type ned_pos_y;

   typedef double _ned_pos_z_type;
  _ned_pos_z_type ned_pos_z;

   typedef double _ned_vel_x_type;
  _ned_vel_x_type ned_vel_x;

   typedef double _ned_vel_y_type;
  _ned_vel_y_type ned_vel_y;

   typedef double _ned_vel_z_type;
  _ned_vel_z_type ned_vel_z;

   typedef double _ned_acc_x_type;
  _ned_acc_x_type ned_acc_x;

   typedef double _ned_acc_y_type;
  _ned_acc_y_type ned_acc_y;

   typedef double _ned_acc_z_type;
  _ned_acc_z_type ned_acc_z;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _ned_acc_type;
  _ned_acc_type ned_acc;

   typedef double _body_acc_x_type;
  _body_acc_x_type body_acc_x;

   typedef double _body_acc_y_type;
  _body_acc_y_type body_acc_y;

   typedef double _body_acc_z_type;
  _body_acc_z_type body_acc_z;

   typedef  ::geometry_msgs::Vector3_<ContainerAllocator>  _body_acc_type;
  _body_acc_type body_acc;

   typedef double _battery_voltage_type;
  _battery_voltage_type battery_voltage;

   typedef double _battery_precentage_type;
  _battery_precentage_type battery_precentage;

   typedef double _battery_current_type;
  _battery_current_type battery_current;





  typedef boost::shared_ptr< ::hust_fw_formation_control::FWstates_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::hust_fw_formation_control::FWstates_<ContainerAllocator> const> ConstPtr;

}; // struct FWstates_

typedef ::hust_fw_formation_control::FWstates_<std::allocator<void> > FWstates;

typedef boost::shared_ptr< ::hust_fw_formation_control::FWstates > FWstatesPtr;
typedef boost::shared_ptr< ::hust_fw_formation_control::FWstates const> FWstatesConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::hust_fw_formation_control::FWstates_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::hust_fw_formation_control::FWstates_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::hust_fw_formation_control::FWstates_<ContainerAllocator1> & lhs, const ::hust_fw_formation_control::FWstates_<ContainerAllocator2> & rhs)
{
  return lhs.planeID == rhs.planeID &&
    lhs.target_planeID == rhs.target_planeID &&
    lhs.altitude_lock == rhs.altitude_lock &&
    lhs.in_air == rhs.in_air &&
    lhs.control_mode == rhs.control_mode &&
    lhs.pitch_angle == rhs.pitch_angle &&
    lhs.yaw_angle == rhs.yaw_angle &&
    lhs.yaw_valid == rhs.yaw_valid &&
    lhs.roll_angle == rhs.roll_angle &&
    lhs.roll_traget_angle == rhs.roll_traget_angle &&
    lhs.pitch_traget_angle == rhs.pitch_traget_angle &&
    lhs.yaw_traget_angle == rhs.yaw_traget_angle &&
    lhs.att_quater == rhs.att_quater &&
    lhs.ground_speed_ned_n == rhs.ground_speed_ned_n &&
    lhs.ground_speed_ned_e == rhs.ground_speed_ned_e &&
    lhs.ground_speed_ned_d == rhs.ground_speed_ned_d &&
    lhs.ground_speed == rhs.ground_speed &&
    lhs.ground_speed_traget == rhs.ground_speed_traget &&
    lhs.global_vel_x == rhs.global_vel_x &&
    lhs.global_vel_y == rhs.global_vel_y &&
    lhs.global_vel_z == rhs.global_vel_z &&
    lhs.air_speed == rhs.air_speed &&
    lhs.wind_estimate_x == rhs.wind_estimate_x &&
    lhs.wind_estimate_y == rhs.wind_estimate_y &&
    lhs.wind_estimate_z == rhs.wind_estimate_z &&
    lhs.relative_hight == rhs.relative_hight &&
    lhs.relative_hight_traget == rhs.relative_hight_traget &&
    lhs.latitude == rhs.latitude &&
    lhs.altitude == rhs.altitude &&
    lhs.longitude == rhs.longitude &&
    lhs.relative_alt == rhs.relative_alt &&
    lhs.ned_altitude == rhs.ned_altitude &&
    lhs.ned_pos_x == rhs.ned_pos_x &&
    lhs.ned_pos_y == rhs.ned_pos_y &&
    lhs.ned_pos_z == rhs.ned_pos_z &&
    lhs.ned_vel_x == rhs.ned_vel_x &&
    lhs.ned_vel_y == rhs.ned_vel_y &&
    lhs.ned_vel_z == rhs.ned_vel_z &&
    lhs.ned_acc_x == rhs.ned_acc_x &&
    lhs.ned_acc_y == rhs.ned_acc_y &&
    lhs.ned_acc_z == rhs.ned_acc_z &&
    lhs.ned_acc == rhs.ned_acc &&
    lhs.body_acc_x == rhs.body_acc_x &&
    lhs.body_acc_y == rhs.body_acc_y &&
    lhs.body_acc_z == rhs.body_acc_z &&
    lhs.body_acc == rhs.body_acc &&
    lhs.battery_voltage == rhs.battery_voltage &&
    lhs.battery_precentage == rhs.battery_precentage &&
    lhs.battery_current == rhs.battery_current;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::hust_fw_formation_control::FWstates_<ContainerAllocator1> & lhs, const ::hust_fw_formation_control::FWstates_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace hust_fw_formation_control

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::hust_fw_formation_control::FWstates_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::hust_fw_formation_control::FWstates_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::hust_fw_formation_control::FWstates_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::hust_fw_formation_control::FWstates_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::hust_fw_formation_control::FWstates_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::hust_fw_formation_control::FWstates_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::hust_fw_formation_control::FWstates_<ContainerAllocator> >
{
  static const char* value()
  {
    return "3a9dfc7015c39929bc474960d75372d7";
  }

  static const char* value(const ::hust_fw_formation_control::FWstates_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x3a9dfc7015c39929ULL;
  static const uint64_t static_value2 = 0xbc474960d75372d7ULL;
};

template<class ContainerAllocator>
struct DataType< ::hust_fw_formation_control::FWstates_<ContainerAllocator> >
{
  static const char* value()
  {
    return "hust_fw_formation_control/FWstates";
  }

  static const char* value(const ::hust_fw_formation_control::FWstates_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::hust_fw_formation_control::FWstates_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Message 固定翼的编队控制，可能用到的消息类型全定义\n"
"uint16 planeID\n"
"\n"
"uint16 target_planeID\n"
"\n"
"bool altitude_lock\n"
"\n"
"bool in_air\n"
"\n"
"string control_mode\n"
"\n"
"float64 pitch_angle\n"
"\n"
"float64 yaw_angle\n"
"\n"
"bool yaw_valid\n"
"\n"
"float64 roll_angle\n"
"\n"
"float64 roll_traget_angle\n"
"\n"
"float64 pitch_traget_angle\n"
"\n"
"float64 yaw_traget_angle\n"
"\n"
"\n"
"geometry_msgs/Quaternion att_quater #姿态四元数，只能在外面弄下旋转矩阵了\n"
"\n"
"float64 ground_speed_ned_n\n"
"\n"
"float64 ground_speed_ned_e\n"
"\n"
"float64 ground_speed_ned_d\n"
"\n"
"float64 ground_speed\n"
"\n"
"float64 ground_speed_traget\n"
"\n"
"float64 global_vel_x\n"
"\n"
"float64 global_vel_y\n"
"\n"
"float64 global_vel_z\n"
"\n"
"\n"
"float64 air_speed\n"
"\n"
"float64 wind_estimate_x\n"
"\n"
"float64 wind_estimate_y\n"
"\n"
"float64 wind_estimate_z\n"
"\n"
"float64 relative_hight\n"
"\n"
"float64 relative_hight_traget\n"
"\n"
"float64 latitude\n"
"\n"
"float64 altitude\n"
"\n"
"float64 longitude\n"
"\n"
"float64 relative_alt\n"
"\n"
"float64 ned_altitude\n"
"\n"
"float64 ned_pos_x\n"
"\n"
"float64 ned_pos_y\n"
"\n"
"float64 ned_pos_z\n"
"\n"
"float64 ned_vel_x\n"
"\n"
"float64 ned_vel_y\n"
"\n"
"float64 ned_vel_z\n"
"\n"
"float64 ned_acc_x\n"
"\n"
"float64 ned_acc_y\n"
"\n"
"float64 ned_acc_z\n"
"\n"
"geometry_msgs/Vector3 ned_acc\n"
"\n"
"float64 body_acc_x\n"
"\n"
"float64 body_acc_y\n"
"\n"
"float64 body_acc_z\n"
"\n"
"geometry_msgs/Vector3 body_acc\n"
"\n"
"float64 battery_voltage\n"
"\n"
"float64 battery_precentage\n"
"\n"
"float64 battery_current\n"
"================================================================================\n"
"MSG: geometry_msgs/Quaternion\n"
"# This represents an orientation in free space in quaternion form.\n"
"\n"
"float64 x\n"
"float64 y\n"
"float64 z\n"
"float64 w\n"
"\n"
"================================================================================\n"
"MSG: geometry_msgs/Vector3\n"
"# This represents a vector in free space. \n"
"# It is only meant to represent a direction. Therefore, it does not\n"
"# make sense to apply a translation to it (e.g., when applying a \n"
"# generic rigid transformation to a Vector3, tf2 will only apply the\n"
"# rotation). If you want your data to be translatable too, use the\n"
"# geometry_msgs/Point message instead.\n"
"\n"
"float64 x\n"
"float64 y\n"
"float64 z\n"
;
  }

  static const char* value(const ::hust_fw_formation_control::FWstates_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::hust_fw_formation_control::FWstates_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.planeID);
      stream.next(m.target_planeID);
      stream.next(m.altitude_lock);
      stream.next(m.in_air);
      stream.next(m.control_mode);
      stream.next(m.pitch_angle);
      stream.next(m.yaw_angle);
      stream.next(m.yaw_valid);
      stream.next(m.roll_angle);
      stream.next(m.roll_traget_angle);
      stream.next(m.pitch_traget_angle);
      stream.next(m.yaw_traget_angle);
      stream.next(m.att_quater);
      stream.next(m.ground_speed_ned_n);
      stream.next(m.ground_speed_ned_e);
      stream.next(m.ground_speed_ned_d);
      stream.next(m.ground_speed);
      stream.next(m.ground_speed_traget);
      stream.next(m.global_vel_x);
      stream.next(m.global_vel_y);
      stream.next(m.global_vel_z);
      stream.next(m.air_speed);
      stream.next(m.wind_estimate_x);
      stream.next(m.wind_estimate_y);
      stream.next(m.wind_estimate_z);
      stream.next(m.relative_hight);
      stream.next(m.relative_hight_traget);
      stream.next(m.latitude);
      stream.next(m.altitude);
      stream.next(m.longitude);
      stream.next(m.relative_alt);
      stream.next(m.ned_altitude);
      stream.next(m.ned_pos_x);
      stream.next(m.ned_pos_y);
      stream.next(m.ned_pos_z);
      stream.next(m.ned_vel_x);
      stream.next(m.ned_vel_y);
      stream.next(m.ned_vel_z);
      stream.next(m.ned_acc_x);
      stream.next(m.ned_acc_y);
      stream.next(m.ned_acc_z);
      stream.next(m.ned_acc);
      stream.next(m.body_acc_x);
      stream.next(m.body_acc_y);
      stream.next(m.body_acc_z);
      stream.next(m.body_acc);
      stream.next(m.battery_voltage);
      stream.next(m.battery_precentage);
      stream.next(m.battery_current);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct FWstates_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::hust_fw_formation_control::FWstates_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::hust_fw_formation_control::FWstates_<ContainerAllocator>& v)
  {
    s << indent << "planeID: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.planeID);
    s << indent << "target_planeID: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.target_planeID);
    s << indent << "altitude_lock: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.altitude_lock);
    s << indent << "in_air: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.in_air);
    s << indent << "control_mode: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.control_mode);
    s << indent << "pitch_angle: ";
    Printer<double>::stream(s, indent + "  ", v.pitch_angle);
    s << indent << "yaw_angle: ";
    Printer<double>::stream(s, indent + "  ", v.yaw_angle);
    s << indent << "yaw_valid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.yaw_valid);
    s << indent << "roll_angle: ";
    Printer<double>::stream(s, indent + "  ", v.roll_angle);
    s << indent << "roll_traget_angle: ";
    Printer<double>::stream(s, indent + "  ", v.roll_traget_angle);
    s << indent << "pitch_traget_angle: ";
    Printer<double>::stream(s, indent + "  ", v.pitch_traget_angle);
    s << indent << "yaw_traget_angle: ";
    Printer<double>::stream(s, indent + "  ", v.yaw_traget_angle);
    s << indent << "att_quater: ";
    s << std::endl;
    Printer< ::geometry_msgs::Quaternion_<ContainerAllocator> >::stream(s, indent + "  ", v.att_quater);
    s << indent << "ground_speed_ned_n: ";
    Printer<double>::stream(s, indent + "  ", v.ground_speed_ned_n);
    s << indent << "ground_speed_ned_e: ";
    Printer<double>::stream(s, indent + "  ", v.ground_speed_ned_e);
    s << indent << "ground_speed_ned_d: ";
    Printer<double>::stream(s, indent + "  ", v.ground_speed_ned_d);
    s << indent << "ground_speed: ";
    Printer<double>::stream(s, indent + "  ", v.ground_speed);
    s << indent << "ground_speed_traget: ";
    Printer<double>::stream(s, indent + "  ", v.ground_speed_traget);
    s << indent << "global_vel_x: ";
    Printer<double>::stream(s, indent + "  ", v.global_vel_x);
    s << indent << "global_vel_y: ";
    Printer<double>::stream(s, indent + "  ", v.global_vel_y);
    s << indent << "global_vel_z: ";
    Printer<double>::stream(s, indent + "  ", v.global_vel_z);
    s << indent << "air_speed: ";
    Printer<double>::stream(s, indent + "  ", v.air_speed);
    s << indent << "wind_estimate_x: ";
    Printer<double>::stream(s, indent + "  ", v.wind_estimate_x);
    s << indent << "wind_estimate_y: ";
    Printer<double>::stream(s, indent + "  ", v.wind_estimate_y);
    s << indent << "wind_estimate_z: ";
    Printer<double>::stream(s, indent + "  ", v.wind_estimate_z);
    s << indent << "relative_hight: ";
    Printer<double>::stream(s, indent + "  ", v.relative_hight);
    s << indent << "relative_hight_traget: ";
    Printer<double>::stream(s, indent + "  ", v.relative_hight_traget);
    s << indent << "latitude: ";
    Printer<double>::stream(s, indent + "  ", v.latitude);
    s << indent << "altitude: ";
    Printer<double>::stream(s, indent + "  ", v.altitude);
    s << indent << "longitude: ";
    Printer<double>::stream(s, indent + "  ", v.longitude);
    s << indent << "relative_alt: ";
    Printer<double>::stream(s, indent + "  ", v.relative_alt);
    s << indent << "ned_altitude: ";
    Printer<double>::stream(s, indent + "  ", v.ned_altitude);
    s << indent << "ned_pos_x: ";
    Printer<double>::stream(s, indent + "  ", v.ned_pos_x);
    s << indent << "ned_pos_y: ";
    Printer<double>::stream(s, indent + "  ", v.ned_pos_y);
    s << indent << "ned_pos_z: ";
    Printer<double>::stream(s, indent + "  ", v.ned_pos_z);
    s << indent << "ned_vel_x: ";
    Printer<double>::stream(s, indent + "  ", v.ned_vel_x);
    s << indent << "ned_vel_y: ";
    Printer<double>::stream(s, indent + "  ", v.ned_vel_y);
    s << indent << "ned_vel_z: ";
    Printer<double>::stream(s, indent + "  ", v.ned_vel_z);
    s << indent << "ned_acc_x: ";
    Printer<double>::stream(s, indent + "  ", v.ned_acc_x);
    s << indent << "ned_acc_y: ";
    Printer<double>::stream(s, indent + "  ", v.ned_acc_y);
    s << indent << "ned_acc_z: ";
    Printer<double>::stream(s, indent + "  ", v.ned_acc_z);
    s << indent << "ned_acc: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.ned_acc);
    s << indent << "body_acc_x: ";
    Printer<double>::stream(s, indent + "  ", v.body_acc_x);
    s << indent << "body_acc_y: ";
    Printer<double>::stream(s, indent + "  ", v.body_acc_y);
    s << indent << "body_acc_z: ";
    Printer<double>::stream(s, indent + "  ", v.body_acc_z);
    s << indent << "body_acc: ";
    s << std::endl;
    Printer< ::geometry_msgs::Vector3_<ContainerAllocator> >::stream(s, indent + "  ", v.body_acc);
    s << indent << "battery_voltage: ";
    Printer<double>::stream(s, indent + "  ", v.battery_voltage);
    s << indent << "battery_precentage: ";
    Printer<double>::stream(s, indent + "  ", v.battery_precentage);
    s << indent << "battery_current: ";
    Printer<double>::stream(s, indent + "  ", v.battery_current);
  }
};

} // namespace message_operations
} // namespace ros

#endif // HUST_FW_FORMATION_CONTROL_MESSAGE_FWSTATES_H
