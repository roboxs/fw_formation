// Generated by gencpp from file hust_fw_formation_control/Leaderstates.msg
// DO NOT EDIT!


#ifndef HUST_FW_FORMATION_CONTROL_MESSAGE_LEADERSTATES_H
#define HUST_FW_FORMATION_CONTROL_MESSAGE_LEADERSTATES_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace hust_fw_formation_control
{
template <class ContainerAllocator>
struct Leaderstates_
{
  typedef Leaderstates_<ContainerAllocator> Type;

  Leaderstates_()
    : pitch_angle(0.0)
    , yaw_angle(0.0)
    , yaw_valid(false)
    , roll_angle(0.0)
    , thrust(0.0)
    , latitude(0.0)
    , altitude(0.0)
    , longitude(0.0)
    , relative_alt(0.0)
    , airspeed(0.0)
    , ned_vel_x(0.0)
    , ned_vel_y(0.0)
    , ned_vel_z(0.0)
    , global_vel_x(0.0)
    , global_vel_y(0.0)
    , global_vel_z(0.0)
    , ned_acc_x(0.0)
    , ned_acc_y(0.0)
    , ned_acc_z(0.0)
    , body_acc_x(0.0)
    , body_acc_y(0.0)
    , body_acc_z(0.0)
    , rel_pos_Xb(0.0)
    , rel_pos_Yb(0.0)
    , rel_pos_Zb(0.0)
    , rel_vel_Xb(0.0)
    , rel_vel_Yb(0.0)
    , rel_vel_Zb(0.0)
    , rel_angle_a(0.0)
    , rel_angle_b(0.0)
    , rel_angle_c(0.0)
    , rel_att_pitch(0.0)
    , rel_att_roll(0.0)
    , rel_att_yaw(0.0)  {
    }
  Leaderstates_(const ContainerAllocator& _alloc)
    : pitch_angle(0.0)
    , yaw_angle(0.0)
    , yaw_valid(false)
    , roll_angle(0.0)
    , thrust(0.0)
    , latitude(0.0)
    , altitude(0.0)
    , longitude(0.0)
    , relative_alt(0.0)
    , airspeed(0.0)
    , ned_vel_x(0.0)
    , ned_vel_y(0.0)
    , ned_vel_z(0.0)
    , global_vel_x(0.0)
    , global_vel_y(0.0)
    , global_vel_z(0.0)
    , ned_acc_x(0.0)
    , ned_acc_y(0.0)
    , ned_acc_z(0.0)
    , body_acc_x(0.0)
    , body_acc_y(0.0)
    , body_acc_z(0.0)
    , rel_pos_Xb(0.0)
    , rel_pos_Yb(0.0)
    , rel_pos_Zb(0.0)
    , rel_vel_Xb(0.0)
    , rel_vel_Yb(0.0)
    , rel_vel_Zb(0.0)
    , rel_angle_a(0.0)
    , rel_angle_b(0.0)
    , rel_angle_c(0.0)
    , rel_att_pitch(0.0)
    , rel_att_roll(0.0)
    , rel_att_yaw(0.0)  {
  (void)_alloc;
    }



   typedef double _pitch_angle_type;
  _pitch_angle_type pitch_angle;

   typedef double _yaw_angle_type;
  _yaw_angle_type yaw_angle;

   typedef uint8_t _yaw_valid_type;
  _yaw_valid_type yaw_valid;

   typedef double _roll_angle_type;
  _roll_angle_type roll_angle;

   typedef double _thrust_type;
  _thrust_type thrust;

   typedef double _latitude_type;
  _latitude_type latitude;

   typedef double _altitude_type;
  _altitude_type altitude;

   typedef double _longitude_type;
  _longitude_type longitude;

   typedef double _relative_alt_type;
  _relative_alt_type relative_alt;

   typedef double _airspeed_type;
  _airspeed_type airspeed;

   typedef double _ned_vel_x_type;
  _ned_vel_x_type ned_vel_x;

   typedef double _ned_vel_y_type;
  _ned_vel_y_type ned_vel_y;

   typedef double _ned_vel_z_type;
  _ned_vel_z_type ned_vel_z;

   typedef double _global_vel_x_type;
  _global_vel_x_type global_vel_x;

   typedef double _global_vel_y_type;
  _global_vel_y_type global_vel_y;

   typedef double _global_vel_z_type;
  _global_vel_z_type global_vel_z;

   typedef double _ned_acc_x_type;
  _ned_acc_x_type ned_acc_x;

   typedef double _ned_acc_y_type;
  _ned_acc_y_type ned_acc_y;

   typedef double _ned_acc_z_type;
  _ned_acc_z_type ned_acc_z;

   typedef double _body_acc_x_type;
  _body_acc_x_type body_acc_x;

   typedef double _body_acc_y_type;
  _body_acc_y_type body_acc_y;

   typedef double _body_acc_z_type;
  _body_acc_z_type body_acc_z;

   typedef double _rel_pos_Xb_type;
  _rel_pos_Xb_type rel_pos_Xb;

   typedef double _rel_pos_Yb_type;
  _rel_pos_Yb_type rel_pos_Yb;

   typedef double _rel_pos_Zb_type;
  _rel_pos_Zb_type rel_pos_Zb;

   typedef double _rel_vel_Xb_type;
  _rel_vel_Xb_type rel_vel_Xb;

   typedef double _rel_vel_Yb_type;
  _rel_vel_Yb_type rel_vel_Yb;

   typedef double _rel_vel_Zb_type;
  _rel_vel_Zb_type rel_vel_Zb;

   typedef double _rel_angle_a_type;
  _rel_angle_a_type rel_angle_a;

   typedef double _rel_angle_b_type;
  _rel_angle_b_type rel_angle_b;

   typedef double _rel_angle_c_type;
  _rel_angle_c_type rel_angle_c;

   typedef double _rel_att_pitch_type;
  _rel_att_pitch_type rel_att_pitch;

   typedef double _rel_att_roll_type;
  _rel_att_roll_type rel_att_roll;

   typedef double _rel_att_yaw_type;
  _rel_att_yaw_type rel_att_yaw;





  typedef boost::shared_ptr< ::hust_fw_formation_control::Leaderstates_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::hust_fw_formation_control::Leaderstates_<ContainerAllocator> const> ConstPtr;

}; // struct Leaderstates_

typedef ::hust_fw_formation_control::Leaderstates_<std::allocator<void> > Leaderstates;

typedef boost::shared_ptr< ::hust_fw_formation_control::Leaderstates > LeaderstatesPtr;
typedef boost::shared_ptr< ::hust_fw_formation_control::Leaderstates const> LeaderstatesConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::hust_fw_formation_control::Leaderstates_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::hust_fw_formation_control::Leaderstates_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::hust_fw_formation_control::Leaderstates_<ContainerAllocator1> & lhs, const ::hust_fw_formation_control::Leaderstates_<ContainerAllocator2> & rhs)
{
  return lhs.pitch_angle == rhs.pitch_angle &&
    lhs.yaw_angle == rhs.yaw_angle &&
    lhs.yaw_valid == rhs.yaw_valid &&
    lhs.roll_angle == rhs.roll_angle &&
    lhs.thrust == rhs.thrust &&
    lhs.latitude == rhs.latitude &&
    lhs.altitude == rhs.altitude &&
    lhs.longitude == rhs.longitude &&
    lhs.relative_alt == rhs.relative_alt &&
    lhs.airspeed == rhs.airspeed &&
    lhs.ned_vel_x == rhs.ned_vel_x &&
    lhs.ned_vel_y == rhs.ned_vel_y &&
    lhs.ned_vel_z == rhs.ned_vel_z &&
    lhs.global_vel_x == rhs.global_vel_x &&
    lhs.global_vel_y == rhs.global_vel_y &&
    lhs.global_vel_z == rhs.global_vel_z &&
    lhs.ned_acc_x == rhs.ned_acc_x &&
    lhs.ned_acc_y == rhs.ned_acc_y &&
    lhs.ned_acc_z == rhs.ned_acc_z &&
    lhs.body_acc_x == rhs.body_acc_x &&
    lhs.body_acc_y == rhs.body_acc_y &&
    lhs.body_acc_z == rhs.body_acc_z &&
    lhs.rel_pos_Xb == rhs.rel_pos_Xb &&
    lhs.rel_pos_Yb == rhs.rel_pos_Yb &&
    lhs.rel_pos_Zb == rhs.rel_pos_Zb &&
    lhs.rel_vel_Xb == rhs.rel_vel_Xb &&
    lhs.rel_vel_Yb == rhs.rel_vel_Yb &&
    lhs.rel_vel_Zb == rhs.rel_vel_Zb &&
    lhs.rel_angle_a == rhs.rel_angle_a &&
    lhs.rel_angle_b == rhs.rel_angle_b &&
    lhs.rel_angle_c == rhs.rel_angle_c &&
    lhs.rel_att_pitch == rhs.rel_att_pitch &&
    lhs.rel_att_roll == rhs.rel_att_roll &&
    lhs.rel_att_yaw == rhs.rel_att_yaw;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::hust_fw_formation_control::Leaderstates_<ContainerAllocator1> & lhs, const ::hust_fw_formation_control::Leaderstates_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace hust_fw_formation_control

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::hust_fw_formation_control::Leaderstates_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::hust_fw_formation_control::Leaderstates_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::hust_fw_formation_control::Leaderstates_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::hust_fw_formation_control::Leaderstates_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::hust_fw_formation_control::Leaderstates_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::hust_fw_formation_control::Leaderstates_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::hust_fw_formation_control::Leaderstates_<ContainerAllocator> >
{
  static const char* value()
  {
    return "68a80b14eea42d16a0353d5db35bf100";
  }

  static const char* value(const ::hust_fw_formation_control::Leaderstates_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x68a80b14eea42d16ULL;
  static const uint64_t static_value2 = 0xa0353d5db35bf100ULL;
};

template<class ContainerAllocator>
struct DataType< ::hust_fw_formation_control::Leaderstates_<ContainerAllocator> >
{
  static const char* value()
  {
    return "hust_fw_formation_control/Leaderstates";
  }

  static const char* value(const ::hust_fw_formation_control::Leaderstates_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::hust_fw_formation_control::Leaderstates_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#本消息是定义的领机的状态消息，同样也包含了相对运动的关系\n"
"\n"
"#如果能得到领机的当前姿态信息，相当于协同\n"
"float64 pitch_angle\n"
"\n"
"float64 yaw_angle\n"
"\n"
"bool yaw_valid\n"
"\n"
"float64 roll_angle\n"
"\n"
"float64 thrust#这个有点不好获得\n"
"\n"
"#领机的绝对位置速度信息\n"
"float64 latitude\n"
"\n"
"float64 altitude\n"
"\n"
"float64 longitude\n"
"\n"
"float64 relative_alt\n"
"\n"
"float64 airspeed\n"
"\n"
"float64 ned_vel_x\n"
"\n"
"float64 ned_vel_y\n"
"\n"
"float64 ned_vel_z\n"
"\n"
"float64 global_vel_x\n"
"\n"
"float64 global_vel_y\n"
"\n"
"float64 global_vel_z\n"
"\n"
"float64 ned_acc_x\n"
"\n"
"float64 ned_acc_y\n"
"\n"
"float64 ned_acc_z\n"
"\n"
"float64 body_acc_x\n"
"\n"
"float64 body_acc_y\n"
"\n"
"float64 body_acc_z\n"
"\n"
"#领机与本机相对位置速度信息\n"
"float64 rel_pos_Xb\n"
"\n"
"float64 rel_pos_Yb\n"
"\n"
"float64 rel_pos_Zb\n"
"\n"
"float64 rel_vel_Xb\n"
"\n"
"float64 rel_vel_Yb\n"
"\n"
"float64 rel_vel_Zb\n"
"\n"
"float64 rel_angle_a#相对角度，之后再改名\n"
"\n"
"float64 rel_angle_b\n"
"\n"
"float64 rel_angle_c\n"
"\n"
"float64 rel_att_pitch\n"
"\n"
"float64 rel_att_roll\n"
"\n"
"float64 rel_att_yaw\n"
;
  }

  static const char* value(const ::hust_fw_formation_control::Leaderstates_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::hust_fw_formation_control::Leaderstates_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.pitch_angle);
      stream.next(m.yaw_angle);
      stream.next(m.yaw_valid);
      stream.next(m.roll_angle);
      stream.next(m.thrust);
      stream.next(m.latitude);
      stream.next(m.altitude);
      stream.next(m.longitude);
      stream.next(m.relative_alt);
      stream.next(m.airspeed);
      stream.next(m.ned_vel_x);
      stream.next(m.ned_vel_y);
      stream.next(m.ned_vel_z);
      stream.next(m.global_vel_x);
      stream.next(m.global_vel_y);
      stream.next(m.global_vel_z);
      stream.next(m.ned_acc_x);
      stream.next(m.ned_acc_y);
      stream.next(m.ned_acc_z);
      stream.next(m.body_acc_x);
      stream.next(m.body_acc_y);
      stream.next(m.body_acc_z);
      stream.next(m.rel_pos_Xb);
      stream.next(m.rel_pos_Yb);
      stream.next(m.rel_pos_Zb);
      stream.next(m.rel_vel_Xb);
      stream.next(m.rel_vel_Yb);
      stream.next(m.rel_vel_Zb);
      stream.next(m.rel_angle_a);
      stream.next(m.rel_angle_b);
      stream.next(m.rel_angle_c);
      stream.next(m.rel_att_pitch);
      stream.next(m.rel_att_roll);
      stream.next(m.rel_att_yaw);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Leaderstates_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::hust_fw_formation_control::Leaderstates_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::hust_fw_formation_control::Leaderstates_<ContainerAllocator>& v)
  {
    s << indent << "pitch_angle: ";
    Printer<double>::stream(s, indent + "  ", v.pitch_angle);
    s << indent << "yaw_angle: ";
    Printer<double>::stream(s, indent + "  ", v.yaw_angle);
    s << indent << "yaw_valid: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.yaw_valid);
    s << indent << "roll_angle: ";
    Printer<double>::stream(s, indent + "  ", v.roll_angle);
    s << indent << "thrust: ";
    Printer<double>::stream(s, indent + "  ", v.thrust);
    s << indent << "latitude: ";
    Printer<double>::stream(s, indent + "  ", v.latitude);
    s << indent << "altitude: ";
    Printer<double>::stream(s, indent + "  ", v.altitude);
    s << indent << "longitude: ";
    Printer<double>::stream(s, indent + "  ", v.longitude);
    s << indent << "relative_alt: ";
    Printer<double>::stream(s, indent + "  ", v.relative_alt);
    s << indent << "airspeed: ";
    Printer<double>::stream(s, indent + "  ", v.airspeed);
    s << indent << "ned_vel_x: ";
    Printer<double>::stream(s, indent + "  ", v.ned_vel_x);
    s << indent << "ned_vel_y: ";
    Printer<double>::stream(s, indent + "  ", v.ned_vel_y);
    s << indent << "ned_vel_z: ";
    Printer<double>::stream(s, indent + "  ", v.ned_vel_z);
    s << indent << "global_vel_x: ";
    Printer<double>::stream(s, indent + "  ", v.global_vel_x);
    s << indent << "global_vel_y: ";
    Printer<double>::stream(s, indent + "  ", v.global_vel_y);
    s << indent << "global_vel_z: ";
    Printer<double>::stream(s, indent + "  ", v.global_vel_z);
    s << indent << "ned_acc_x: ";
    Printer<double>::stream(s, indent + "  ", v.ned_acc_x);
    s << indent << "ned_acc_y: ";
    Printer<double>::stream(s, indent + "  ", v.ned_acc_y);
    s << indent << "ned_acc_z: ";
    Printer<double>::stream(s, indent + "  ", v.ned_acc_z);
    s << indent << "body_acc_x: ";
    Printer<double>::stream(s, indent + "  ", v.body_acc_x);
    s << indent << "body_acc_y: ";
    Printer<double>::stream(s, indent + "  ", v.body_acc_y);
    s << indent << "body_acc_z: ";
    Printer<double>::stream(s, indent + "  ", v.body_acc_z);
    s << indent << "rel_pos_Xb: ";
    Printer<double>::stream(s, indent + "  ", v.rel_pos_Xb);
    s << indent << "rel_pos_Yb: ";
    Printer<double>::stream(s, indent + "  ", v.rel_pos_Yb);
    s << indent << "rel_pos_Zb: ";
    Printer<double>::stream(s, indent + "  ", v.rel_pos_Zb);
    s << indent << "rel_vel_Xb: ";
    Printer<double>::stream(s, indent + "  ", v.rel_vel_Xb);
    s << indent << "rel_vel_Yb: ";
    Printer<double>::stream(s, indent + "  ", v.rel_vel_Yb);
    s << indent << "rel_vel_Zb: ";
    Printer<double>::stream(s, indent + "  ", v.rel_vel_Zb);
    s << indent << "rel_angle_a: ";
    Printer<double>::stream(s, indent + "  ", v.rel_angle_a);
    s << indent << "rel_angle_b: ";
    Printer<double>::stream(s, indent + "  ", v.rel_angle_b);
    s << indent << "rel_angle_c: ";
    Printer<double>::stream(s, indent + "  ", v.rel_angle_c);
    s << indent << "rel_att_pitch: ";
    Printer<double>::stream(s, indent + "  ", v.rel_att_pitch);
    s << indent << "rel_att_roll: ";
    Printer<double>::stream(s, indent + "  ", v.rel_att_roll);
    s << indent << "rel_att_yaw: ";
    Printer<double>::stream(s, indent + "  ", v.rel_att_yaw);
  }
};

} // namespace message_operations
} // namespace ros

#endif // HUST_FW_FORMATION_CONTROL_MESSAGE_LEADERSTATES_H
